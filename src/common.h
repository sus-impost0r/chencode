#if !COMMON_H_INCLUDED
#define COMMON_H_INCLUDED 1
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

/* By Mark Adler -- stolen from: https://stackoverflow.com/a/48358614 */
uint16_t crc16(uint16_t crc,
               const unsigned char *restrict data,
               size_t len) {
    static const uint16_t crc16_tbl[256] = {
        0xed35, 0xdb6b, 0x8189, 0xb7d7, 0x344d, 0x0213, 0x58f1, 0x6eaf,
        0x12bc, 0x24e2, 0x7e00, 0x485e, 0xcbc4, 0xfd9a, 0xa778, 0x9126,
        0x5f5e, 0x6900, 0x33e2, 0x05bc, 0x8626, 0xb078, 0xea9a, 0xdcc4,
        0xa0d7, 0x9689, 0xcc6b, 0xfa35, 0x79af, 0x4ff1, 0x1513, 0x234d,
        0xc49a, 0xf2c4, 0xa826, 0x9e78, 0x1de2, 0x2bbc, 0x715e, 0x4700,
        0x3b13, 0x0d4d, 0x57af, 0x61f1, 0xe26b, 0xd435, 0x8ed7, 0xb889,
        0x76f1, 0x40af, 0x1a4d, 0x2c13, 0xaf89, 0x99d7, 0xc335, 0xf56b,
        0x8978, 0xbf26, 0xe5c4, 0xd39a, 0x5000, 0x665e, 0x3cbc, 0x0ae2,
        0xbe6b, 0x8835, 0xd2d7, 0xe489, 0x6713, 0x514d, 0x0baf, 0x3df1,
        0x41e2, 0x77bc, 0x2d5e, 0x1b00, 0x989a, 0xaec4, 0xf426, 0xc278,
        0x0c00, 0x3a5e, 0x60bc, 0x56e2, 0xd578, 0xe326, 0xb9c4, 0x8f9a,
        0xf389, 0xc5d7, 0x9f35, 0xa96b, 0x2af1, 0x1caf, 0x464d, 0x7013,
        0x97c4, 0xa19a, 0xfb78, 0xcd26, 0x4ebc, 0x78e2, 0x2200, 0x145e,
        0x684d, 0x5e13, 0x04f1, 0x32af, 0xb135, 0x876b, 0xdd89, 0xebd7,
        0x25af, 0x13f1, 0x4913, 0x7f4d, 0xfcd7, 0xca89, 0x906b, 0xa635,
        0xda26, 0xec78, 0xb69a, 0x80c4, 0x035e, 0x3500, 0x6fe2, 0x59bc,
        0x4b89, 0x7dd7, 0x2735, 0x116b, 0x92f1, 0xa4af, 0xfe4d, 0xc813,
        0xb400, 0x825e, 0xd8bc, 0xeee2, 0x6d78, 0x5b26, 0x01c4, 0x379a,
        0xf9e2, 0xcfbc, 0x955e, 0xa300, 0x209a, 0x16c4, 0x4c26, 0x7a78,
        0x066b, 0x3035, 0x6ad7, 0x5c89, 0xdf13, 0xe94d, 0xb3af, 0x85f1,
        0x6226, 0x5478, 0x0e9a, 0x38c4, 0xbb5e, 0x8d00, 0xd7e2, 0xe1bc,
        0x9daf, 0xabf1, 0xf113, 0xc74d, 0x44d7, 0x7289, 0x286b, 0x1e35,
        0xd04d, 0xe613, 0xbcf1, 0x8aaf, 0x0935, 0x3f6b, 0x6589, 0x53d7,
        0x2fc4, 0x199a, 0x4378, 0x7526, 0xf6bc, 0xc0e2, 0x9a00, 0xac5e,
        0x18d7, 0x2e89, 0x746b, 0x4235, 0xc1af, 0xf7f1, 0xad13, 0x9b4d,
        0xe75e, 0xd100, 0x8be2, 0xbdbc, 0x3e26, 0x0878, 0x529a, 0x64c4,
        0xaabc, 0x9ce2, 0xc600, 0xf05e, 0x73c4, 0x459a, 0x1f78, 0x2926,
        0x5535, 0x636b, 0x3989, 0x0fd7, 0x8c4d, 0xba13, 0xe0f1, 0xd6af,
        0x3178, 0x0726, 0x5dc4, 0x6b9a, 0xe800, 0xde5e, 0x84bc, 0xb2e2,
        0xcef1, 0xf8af, 0xa24d, 0x9413, 0x1789, 0x21d7, 0x7b35, 0x4d6b,
        0x8313, 0xb54d, 0xefaf, 0xd9f1, 0x5a6b, 0x6c35, 0x36d7, 0x0089,
        0x7c9a, 0x4ac4, 0x1026, 0x2678, 0xa5e2, 0x93bc, 0xc95e, 0xff00
    };

    while (len--)
        crc = (crc >> 8) ^ crc16_tbl[(crc ^ *data++) & 0xFF];
    return crc;
}


/* By Mark Adler -- stolen from: https://stackoverflow.com/a/51777726 */
static uint8_t crc8(uint8_t crc,
                    const unsigned char *restrict mem,
                    size_t len) {

    static uint8_t const crc8x_table[] = {
        0x00, 0x31, 0x62, 0x53, 0xc4, 0xf5, 0xa6, 0x97, 0xb9, 0x88,
        0xdb, 0xea, 0x7d, 0x4c, 0x1f, 0x2e, 0x43, 0x72, 0x21, 0x10,
        0x87, 0xb6, 0xe5, 0xd4, 0xfa, 0xcb, 0x98, 0xa9, 0x3e, 0x0f,
        0x5c, 0x6d, 0x86, 0xb7, 0xe4, 0xd5, 0x42, 0x73, 0x20, 0x11,
        0x3f, 0x0e, 0x5d, 0x6c, 0xfb, 0xca, 0x99, 0xa8, 0xc5, 0xf4,
        0xa7, 0x96, 0x01, 0x30, 0x63, 0x52, 0x7c, 0x4d, 0x1e, 0x2f,
        0xb8, 0x89, 0xda, 0xeb, 0x3d, 0x0c, 0x5f, 0x6e, 0xf9, 0xc8,
        0x9b, 0xaa, 0x84, 0xb5, 0xe6, 0xd7, 0x40, 0x71, 0x22, 0x13,
        0x7e, 0x4f, 0x1c, 0x2d, 0xba, 0x8b, 0xd8, 0xe9, 0xc7, 0xf6,
        0xa5, 0x94, 0x03, 0x32, 0x61, 0x50, 0xbb, 0x8a, 0xd9, 0xe8,
        0x7f, 0x4e, 0x1d, 0x2c, 0x02, 0x33, 0x60, 0x51, 0xc6, 0xf7,
        0xa4, 0x95, 0xf8, 0xc9, 0x9a, 0xab, 0x3c, 0x0d, 0x5e, 0x6f,
        0x41, 0x70, 0x23, 0x12, 0x85, 0xb4, 0xe7, 0xd6, 0x7a, 0x4b,
        0x18, 0x29, 0xbe, 0x8f, 0xdc, 0xed, 0xc3, 0xf2, 0xa1, 0x90,
        0x07, 0x36, 0x65, 0x54, 0x39, 0x08, 0x5b, 0x6a, 0xfd, 0xcc,
        0x9f, 0xae, 0x80, 0xb1, 0xe2, 0xd3, 0x44, 0x75, 0x26, 0x17,
        0xfc, 0xcd, 0x9e, 0xaf, 0x38, 0x09, 0x5a, 0x6b, 0x45, 0x74,
        0x27, 0x16, 0x81, 0xb0, 0xe3, 0xd2, 0xbf, 0x8e, 0xdd, 0xec,
        0x7b, 0x4a, 0x19, 0x28, 0x06, 0x37, 0x64, 0x55, 0xc2, 0xf3,
        0xa0, 0x91, 0x47, 0x76, 0x25, 0x14, 0x83, 0xb2, 0xe1, 0xd0,
        0xfe, 0xcf, 0x9c, 0xad, 0x3a, 0x0b, 0x58, 0x69, 0x04, 0x35,
        0x66, 0x57, 0xc0, 0xf1, 0xa2, 0x93, 0xbd, 0x8c, 0xdf, 0xee,
        0x79, 0x48, 0x1b, 0x2a, 0xc1, 0xf0, 0xa3, 0x92, 0x05, 0x34,
        0x67, 0x56, 0x78, 0x49, 0x1a, 0x2b, 0xbc, 0x8d, 0xde, 0xef,
        0x82, 0xb3, 0xe0, 0xd1, 0x46, 0x77, 0x24, 0x15, 0x3b, 0x0a,
        0x59, 0x68, 0xff, 0xce, 0x9d, 0xac
    };

    while (len--)
        crc = crc8x_table[crc ^ *mem++];
    return crc;
}



/* New header layout:
   |0x0    |0x1|0x3     |
   |crc_len|len|crc_data|data...
   This uses a CRC16 for crc_data and a
   CRC8 for crc_len, checking length and data
   separately. */
typedef struct {
    uint8_t  crc_len;
    uint16_t len;
    uint16_t crc_data;
} blkhdr_t;


static void read_blkhdr(const unsigned char *const restrict buf,
                        blkhdr_t *bhp) {
    bhp->crc_len  = buf[0];
    bhp->len      = (buf[2] << 8) | buf[1];
    bhp->crc_data = (buf[4] << 8) | buf[3];
}

static void write_blkhdr(unsigned char *restrict buf,
                         const blkhdr_t *const restrict bhp) {
    buf[0] = bhp->crc_len;
    buf[1] = bhp->len & 0xFF;
    buf[2] = bhp->len >> 8;
    buf[3] = bhp->crc_data & 0xFF;
    buf[4] = bhp->crc_data >> 8;
}


static blkhdr_t mk_blkhdr(const uint16_t len,
                          const void *const restrict data) {
    blkhdr_t bh;
    bh.len = len;
    bh.crc_len = crc8(0xFF, &(unsigned char){bh.len & 0xFF}, 1);
    bh.crc_len = crc8(bh.crc_len, &(unsigned char){bh.len >> 8}, 1);
    bh.crc_data = crc16(0xFFFF, (unsigned char *)data, len);
    return bh;
}

static int check_blk(const blkhdr_t *const restrict bhp,
                     const unsigned char *const restrict data) {
    blkhdr_t tbh = mk_blkhdr(bhp->len, data);
    if(tbh.crc_len != bhp->crc_len)
        return -1; /* length corrupted */
    if(tbh.crc_data != bhp->crc_data)
        return -2; /* data corrupted */
    return 0;
}

static ssize_t try_read(int fd, void *buf, size_t len) {
    unsigned char *p = buf;
    size_t n, t = 0;
    while(t < len) {
        n = read(fd, buf + t, len - t);
        if(n < 0) return n;
        if(n == 0) break;
        t += n;
    }
    return t;
}

static ssize_t try_write(int fd, const void *buf, size_t len) {
    const unsigned char *p = buf;
    size_t n, t = 0;
    while(t < len) {
        n = write(fd, buf + t, len - t);
        if(n < 0) return n;
        if(n == 0) break;
        t += n;
    }
    return t;
}


static ssize_t write_block(const int fd,
                           const void *const restrict data,
                           const uint16_t len) {
    blkhdr_t bh;
    ssize_t n, t;
    unsigned char bha[5];

    /* EOF */
    if(!data) {
        bh = mk_blkhdr(0, "");
        write_blkhdr(bha, &bh);
        t = try_write(fd, bha, 5);
        return t;
    }


    bh = mk_blkhdr(len, data);

    write_blkhdr(bha, &bh);

    t = try_write(fd, bha, 5);
    if(t < 5) return t;
    n += t;

    t = try_write(fd, data, len);
    if(t < len) return t;
    n += t;

    return n;
}

static ssize_t read_block(const int fd,
                          void *const restrict data,
                          const size_t avail) {
    blkhdr_t bh;
    ssize_t t;
    uint16_t tmp;
    unsigned char bha[5];

    t = try_read(fd, bha, 5);
    if(t < 5) return t;

    read_blkhdr(bha, &bh);

    /* don't use mk_blkhdr here because we need to check len beforehand */
    tmp = crc8(0xFF, &(unsigned char){bh.len & 0xFF}, 1);
    tmp = crc8(tmp, &(unsigned char){bh.len >> 8}, 1);

    if((tmp & 0xFF) != bh.crc_len)
        return -2; /* length corrupted */

    if(bh.len == 0) return 0;

    if(bh.len > avail) {
        errno = E2BIG;
        return -1; /* too much data */
    }

    t = try_read(fd, data, bh.len);
    if(t < bh.len) return t;

    tmp = crc16(0xFFFF, (unsigned char *)data, bh.len);

    if(bh.crc_data != tmp)
        return -3; /* data corrupted */

    /* all good! */
    return bh.len;
}

#endif
